-- ============================================================
-- Soft delete + restore + audit (idempotent)
-- ============================================================

-- 1) Soft delete columns on items
ALTER TABLE public.items
  ADD COLUMN IF NOT EXISTS deleted_at timestamptz NULL,
  ADD COLUMN IF NOT EXISTS deleted_by_nome text NULL,
  ADD COLUMN IF NOT EXISTS delete_reason text NULL;

-- 2) Recommended indexes
CREATE INDEX IF NOT EXISTS idx_items_period_deleted_at
  ON public.items (periodo_id, deleted_at);

-- Active-only partial index (fast reads for current month active items)
CREATE INDEX IF NOT EXISTS idx_items_period_active_partial
  ON public.items (periodo_id, created_at DESC)
  WHERE deleted_at IS NULL;

-- 3) Audit table
CREATE TABLE IF NOT EXISTS public.audit_log (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  action text NOT NULL,
  collaborator_name text NULL,
  period_id uuid NULL,
  item_id uuid NULL,
  details jsonb NOT NULL DEFAULT '{}'::jsonb,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_audit_log_created_at
  ON public.audit_log (created_at DESC);

CREATE INDEX IF NOT EXISTS idx_audit_log_action
  ON public.audit_log (action);

-- Optional helper view for "default reads": only active items
CREATE OR REPLACE VIEW public.items_active AS
SELECT *
FROM public.items
WHERE deleted_at IS NULL;

-- 4) Functions
-- Soft delete one item
CREATE OR REPLACE FUNCTION public.soft_delete_item(
  item_id uuid,
  deleted_by text,
  reason text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_period_id uuid;
  v_count integer := 0;
BEGIN
  UPDATE public.items
  SET
    deleted_at = now(),
    deleted_by_nome = COALESCE(NULLIF(trim(deleted_by), ''), 'Colaborador'),
    delete_reason = NULLIF(trim(reason), '')
  WHERE id = item_id
    AND deleted_at IS NULL
  RETURNING periodo_id INTO v_period_id;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  IF v_count > 0 THEN
    INSERT INTO public.audit_log (action, collaborator_name, period_id, item_id, details)
    VALUES (
      'ITEM_SOFT_DELETE',
      COALESCE(NULLIF(trim(deleted_by), ''), 'Colaborador'),
      v_period_id,
      item_id,
      jsonb_build_object('reason', reason)
    );
  END IF;

  RETURN v_count;
END;
$$;

-- Soft delete all active items by period
CREATE OR REPLACE FUNCTION public.soft_delete_items_by_period(
  period_id uuid,
  deleted_by text,
  reason text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_count integer := 0;
BEGIN
  UPDATE public.items
  SET
    deleted_at = now(),
    deleted_by_nome = COALESCE(NULLIF(trim(deleted_by), ''), 'Colaborador'),
    delete_reason = NULLIF(trim(reason), '')
  WHERE periodo_id = period_id
    AND deleted_at IS NULL;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  INSERT INTO public.audit_log (action, collaborator_name, period_id, details)
  VALUES (
    'MONTH_SOFT_DELETE',
    COALESCE(NULLIF(trim(deleted_by), ''), 'Colaborador'),
    period_id,
    jsonb_build_object('reason', reason, 'affected_count', v_count)
  );

  RETURN v_count;
END;
$$;

-- Restore all deleted items by period
CREATE OR REPLACE FUNCTION public.restore_items_by_period(
  period_id uuid,
  restored_by text
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_count integer := 0;
BEGIN
  UPDATE public.items
  SET
    deleted_at = NULL,
    deleted_by_nome = NULL,
    delete_reason = NULL
  WHERE periodo_id = period_id
    AND deleted_at IS NOT NULL;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  INSERT INTO public.audit_log (action, collaborator_name, period_id, details)
  VALUES (
    'MONTH_RESTORE',
    COALESCE(NULLIF(trim(restored_by), ''), 'Colaborador'),
    period_id,
    jsonb_build_object('restored_count', v_count)
  );

  RETURN v_count;
END;
$$;

-- Count deleted items by period
CREATE OR REPLACE FUNCTION public.count_deleted_items_by_period(
  period_id uuid
)
RETURNS integer
LANGUAGE sql
AS $$
  SELECT COUNT(*)::integer
  FROM public.items
  WHERE periodo_id = period_id
    AND deleted_at IS NOT NULL
$$;

-- Hard delete only deleted items by period (irreversible)
CREATE OR REPLACE FUNCTION public.purge_deleted_items_by_period(
  period_id uuid,
  purged_by text,
  reason text DEFAULT NULL
)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  v_count integer := 0;
BEGIN
  DELETE FROM public.items
  WHERE periodo_id = period_id
    AND deleted_at IS NOT NULL;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  INSERT INTO public.audit_log (action, collaborator_name, period_id, details)
  VALUES (
    'MONTH_PURGE_DELETED',
    COALESCE(NULLIF(trim(purged_by), ''), 'Colaborador'),
    period_id,
    jsonb_build_object('deleted_count', v_count, 'reason', reason)
  );

  RETURN v_count;
END;
$$;

-- 5) "Default read" rule
-- Prefer reading from public.items_active
-- or always add: WHERE deleted_at IS NULL

-- 6) Examples
-- SELECT public.soft_delete_item('00000000-0000-0000-0000-000000000000', 'Thiago', 'Remoção individual');
-- SELECT public.soft_delete_items_by_period('00000000-0000-0000-0000-000000000000', 'Thiago', 'Limpeza mensal');
-- SELECT public.restore_items_by_period('00000000-0000-0000-0000-000000000000', 'Thiago');
-- SELECT public.count_deleted_items_by_period('00000000-0000-0000-0000-000000000000');
-- SELECT public.purge_deleted_items_by_period('00000000-0000-0000-0000-000000000000', 'Thiago', 'Limpeza definitiva');
-- SELECT * FROM public.items_active WHERE periodo_id = '00000000-0000-0000-0000-000000000000' ORDER BY created_at DESC;
